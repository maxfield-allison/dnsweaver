# DNSWeaver Configuration File Example
#
# This file demonstrates the full YAML configuration format.
# All settings shown with their default values unless marked otherwise.
#
# Configuration priority (highest to lowest):
#   1. Environment variables (DNSWEAVER_* prefix)
#   2. This config file
#   3. Default values
#
# Environment variable interpolation: Use ${VAR} or ${VAR:-default}
# Example: token: ${TECHNITIUM_TOKEN}
#
# ═══════════════════════════════════════════════════════════════════════════════
# SECRETS MANAGEMENT (v0.5.1+)
# ═══════════════════════════════════════════════════════════════════════════════
#
# For sensitive values like API tokens, you have three options:
#
# 1. Inline in YAML (simple, but exposes secrets in config file):
#    config:
#      token: my-secret-token
#
# 2. Environment variable interpolation (requires env var at load time):
#    config:
#      token: ${TECHNITIUM_TOKEN}
#
# 3. Provider-specific env var override (recommended for Docker/K8s secrets):
#    Leave token out of YAML entirely. Set env var at runtime:
#      DNSWEAVER_{PROVIDER_NAME}_TOKEN=secret-value
#    Or use _FILE suffix to read from a file (Docker secrets pattern):
#      DNSWEAVER_{PROVIDER_NAME}_TOKEN_FILE=/run/secrets/dns_token
#
#    Provider name is normalized: uppercase, hyphens become underscores.
#    Example: provider "my-dns" → DNSWEAVER_MY_DNS_TOKEN
#
# Secret fields supporting _FILE suffix:
#   TOKEN, API_KEY, AUTH_TOKEN, PASSWORD
#
# Non-secret fields (env var override only, no _FILE):
#   URL, ZONE, ZONE_ID, API_EMAIL, TARGET, TTL, MODE
# ═══════════════════════════════════════════════════════════════════════════════

# Logging configuration
logging:
  level: info        # debug, info, warn, error
  format: json       # json or text

# Reconciler settings
reconciler:
  interval: 60s           # How often to reconcile DNS records (Go duration)
  dry_run: false          # If true, log changes but don't apply them
  cleanup_orphans: true   # Delete records for removed containers
  cleanup_on_stop: true   # Delete records when containers stop (not just remove)
  ownership_tracking: true # Use TXT records to track record ownership
  adopt_existing: false   # Adopt pre-existing DNS records by creating TXT records

# Docker connection settings
docker:
  host: unix:///var/run/docker.sock  # Docker socket or TCP URL
  mode: auto                          # auto, swarm, or standalone

# Health and metrics server
server:
  port: 8080  # Port for /health, /ready, and /metrics endpoints

# Hostname sources
# Order matters: first source with matching hostname wins
sources:
  # Traefik source with optional file-based discovery
  - name: traefik
    file_discovery:
      paths:
        - /config/traefik/dynamic
      pattern: "*.yml"
      poll_interval: 60s
      watch_method: auto  # auto, inotify, or poll

  # Native dnsweaver labels (no additional config needed)
  - name: dnsweaver

# DNS providers
# Order matters: first matching provider handles the hostname
providers:
  # Internal DNS using Technitium
  - name: internal
    type: technitium
    domains:
      - "*.internal.example.com"
      - "*.home.example.com"
    record_type: A        # A, AAAA, or CNAME
    target: 10.0.0.100    # Where to point DNS records (your load balancer/gateway IP)
    ttl: 300              # TTL in seconds
    mode: managed         # managed, authoritative, or additive
    config:
      url: http://dns.example.com:5380
      token: ${TECHNITIUM_TOKEN}        # env var interpolation
      zone: internal.example.com

  # Public DNS using Cloudflare
  - name: public
    type: cloudflare
    domains:
      - "*.example.com"
    exclude_domains:
      - "*.internal.example.com"    # Don't manage internal subdomains
      - "*.home.example.com"
    record_type: CNAME
    target: lb.example.com          # CNAME target
    ttl: 300
    config:
      api_token: ${CLOUDFLARE_TOKEN}
      zone_id: ${CLOUDFLARE_ZONE_ID}
      proxied: "false"              # Cloudflare proxy status

  # Pi-hole example
  - name: pihole
    type: pihole
    domains:
      - "*.local.example.com"
    record_type: A
    target: 192.168.1.100
    config:
      url: http://pihole.example.com
      token: ${PIHOLE_TOKEN}

  # Webhook provider for custom integrations
  - name: custom
    type: webhook
    domains:
      - "*.custom.example.com"
    record_type: A
    target: 10.0.0.50
    config:
      url: https://webhook.example.com/dns
      auth_header: X-API-Key
      auth_token: ${WEBHOOK_TOKEN}
      timeout: 30s
      retries: "3"
      retry_delay: 5s

# Advanced: Using regex for domain matching
# - name: regex-example
#   type: technitium
#   domains_regex:
#     - "^app-[0-9]+\\.example\\.com$"
#   record_type: A
#   target: 10.0.0.100
#   config:
#     url: http://dns:5380
#     token: ${TECHNITIUM_TOKEN}
#     zone: example.com

# Advanced: Provider with secret injected via environment variable
# This provider has no token in YAML - it's injected at runtime via:
#   DNSWEAVER_SECURE_DNS_TOKEN_FILE=/run/secrets/dns_token  (Docker/K8s)
#   DNSWEAVER_SECURE_DNS_TOKEN=my-token                     (direct value)
#
# - name: secure-dns
#   type: technitium
#   domains:
#     - "*.secure.example.com"
#   record_type: A
#   target: 10.0.0.100
#   config:
#     url: http://dns:5380
#     zone: secure.example.com
#     # TOKEN not set here - injected via DNSWEAVER_SECURE_DNS_TOKEN_FILE
